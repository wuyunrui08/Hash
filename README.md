# Hash
离散表（哈希）
﻿﻿﻿﻿﻿﻿﻿﻿﻿﻿
# 散列表

<h2 id="back"></h2>

#### 简介

- [简述](#introduction)
- [散列函数](#function)
- 

---

<h2 id="introduction"></h2>

我们来讲述散列表。

散列表是一种数据结构，它具有以下性质：

- 应用广泛
- 查找快速
- 等

举个例子。

你在超市工作，一位顾客来购买商品，你家超市刚刚好没有自动销售机，你得亲自去查找该商品的价格。如果我们是这样的话，那么顾客每买一个商品，都要找一下该商品并且知道它的价格。那么我们非常花费时间。如果我们能够找到这样一个人：能够记住所有商品的价格的人。那么我们在帮顾客结账的时候将会非常快速。

即使你是用一个小本本把你商店的东西都记上了，并且是按照一定的顺序记号的。即使使用二分查找，那么我们也会花费一定的时间。想必此时顾客已经不耐烦了。他们可能会说：“怎么这么久！！！”，然后你的商店可能会产生很多很多的怨气......

![photo1](./Photos/photo1.png)

<h2 id="back1"></h2>

我们从数据结构的方面去看这个问题，那么所有的商品就有了这样的一个特性：**商品的key** 以及 **商品的卫星数据**    [---->名词查看<---](#explain)。

![photo2](./Photos/photo2.png)

如果我们按照一个特殊的函数去把相对应的 KEY 值转换成另一个东西，并且记录在小本子上，我们只需直接翻到这个本子相对应的部分，就可以找到了该商品的价格了，以及还有其他的信息。

![photo3](./Photos/photo3.png)

[返回简介](#back)

---

<h2 id="function"></h2>

那么我们的问题来了，我们该怎样创建这个数据类型呢？首先了解一下，散列函数

> 散列函数是“将输入映射到数字”

散列函数可能是没什么规律的，但是也必须得满足一定的要求：

- 必须是一致的，也就是每一个值都有它的唯一确定的一个值与它对应
- 它应该将不同的输入映射到不同的数字中。
- 应该还是离散型分布的，分布越离散，越有助于我们以后的运算
>如果不是离散性的话，那么我们就可能会导致冲突现象特别明显。就比如我们有一个函数是这样的 y=x ^2^ ,那么我们输入-1，+1的时候，他们的值是一样的，此时产生了冲突性.......

散列函数总能够精确地指出我们在小本本写的东西的地址，或者说是第几页、第几条。这样的话，你就基本不用查找了，通过一个函数，直接就能够把这个地址找到了，然后你就可以很快地给别人结账......

主要有以下的原因:

- 散列函数总是将同样的输入映射到相同的地址上。
>也就是说，我每一次调用这个散列函数的时候，它每一次都能给我相同的一个值，并且不会改变。这就说明，当你需要找到一样商品的时候，请你输入商品的 KEY 值，那么其对应的卫星数据就会很容易地被你在小本本上找到

- 散列函数将不同的输入映射到不同的地址中。
>这个也是说，当我们找了商品1，还想找商品2的时候，输入其key值，我们所得到的值也是不一样的。这样就能保证每一个商品都有一个所对应的地址，从而我们能够很好地知道该商品在我们小本本上的页数

- 散列函数是有一个上界的，这个上界就是我们小本本的最大页码。它只能返回我们小本本的最大页码，如果超过了，那这就是一个无效的散列函数。
>就好比如，我们的小本本有50页，那么我们的散列函数如果被输入一个数据之后返回51，那么我们改写到我们小本本的哪个地方呢？对吧。

---

后续......



---

<h2 id="explain"></h2>

### 名词解释

- KEY：商品的key有很多种，比如一个商品有它的名字，商品价格等等，那么我们待会可能需要用到这些东西，所以我把它叫成了KEY
- 商品的卫星数据：所谓的卫星数据呢，就是除了 KEY 以外的其他数据。比如，我们把商品的名字作为了 KEY 之后，那么其他的数据就被称作了卫星数据了。形象地解释就是， KEY 是一个行星，其他的数据就像是卫星一样围着 KEY 转动，就像是卫星一样（这是《算法导论》排序里面的一个名词，我拿来使用了）

[---->BACK<----](#back1)

---

借鉴《算法导论》，《算法图解（图灵程序设计丛书）》







